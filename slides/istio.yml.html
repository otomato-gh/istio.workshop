<!DOCTYPE html>
<html>
  <head>
    <title>Deploy Microservices like a Ninja with Istio Service Mesh </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="workshop.css">
  </head>
  <body>
    <!--
    <div style="position: absolute; left: 20%; right: 20%; top: 30%;">
      <h1 style="font-size: 3em;">Loading ...</h1>
      The slides should show up here. If they don't, it might be
      because you are accessing this file directly from your filesystem.
      It needs to be served from a web server. You can try this:
      <pre>
        docker-compose up -d
        open http://localhost:8888/workshop.html # on MacOS
        xdg-open http://localhost:8888/workshop.html # on Linux
      </pre>
      Once the slides are loaded, this notice disappears when you
      go full screen (e.g. by hitting "f").
    </div>
    -->
    <textarea id="source">class: title, in-person

Deploy Microservices like a Ninja with Istio Service Mesh<br/><br/></br>



.footnote[
*Presented by Anton Weiss*<br/>
*Otomato technical training.*<br/>
*http://otomato.link*

**Slides: https://devopstrain.pro/istio**
]




.debug[[istio/title.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/title.md)]
---
## Intros

 - Hello! I am:

   - Ant Weiss ([@antweiss](https://twitter.com/antweiss), Otomato Software Delivery.)

- This is a full day workshop

- Feel free to interrupt for questions at any time

- *Especially when you see full screen ship pictures!*

- Live feedback, questions, help: [Slack](https://join.slack.com/t/otomato-flux/shared_invite/enQtMzE5NjY1Njk4MzM5LWRkNmI5NGI5YjY0MWVlNjA0ZjdkMjRiMjlkZDY5ZTI4NGE3MWQ1M2E0ZTJlNjA2YTQ4ZjdmNTA4ZjRmODY1ZjY)

.debug[[logistics.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/logistics.md)]
---
## Introduction

- This presentation was created by [Ant Weiss](https://twitter.com/antweiss) to support 
  instructor-led workshops.

- We included as much information as possible in these slides

- Most of the information this workshop is based on is public knowledge and can also be accessed through [Istio official documents and tutorials](https://istio.io/docs)

![image alt ><](images/istio.png)
.debug[[istio/intro.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/intro.md)]
---

## Training environment

- This is a hands-on training with exercises and examples

- We assume that you have access to a Kubernetes cluster

- The training labs for today's session were generously sponsored by [Strigo](https://strigo.io)
- We will be using [microk8s](https://microk8s.io) to get these clusters 

- Haven't tried microk8s yet?! You're in for a treat!

.debug[[istio/intro.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/intro.md)]
---

## Getting Istio

- Get the source code and the slides for this workshop:

.exercise[

- On your Strigo VM:

  ```bash
  git clone https://github.com/otomato-gh/istio.workshop.git 
  cd istio.workshop
  ./prepare_vms/setup_microk8s.sh
  ```

]

- This will install a microk8s single-node cluster with Istio

.debug[[istio/intro.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/intro.md)]
---

### A few words about microk8s

```bash
sudo snap install microk8s --classic                                    
sudo snap install kubectl --classic                                     
microk8s.start                                                          
microk8s.enable istio                                                   
```

- Single node Kubernetes done right

- Zero-ops k8s on just about any Linux box

- Many popular k8s add-ons can be enabled:
  - metrics-server
  - kube-dashboard
  - and of course: Istio
  - For more:  `microk8s.enable --help`



.debug[[istio/intro.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/intro.md)]
---

name: toc-chapter-1

## Chapter 1

- [What is a Service Mesh?](#toc-what-is-a-service-mesh)

.debug[(auto-generated TOC)]
---
name: toc-chapter-2

## Chapter 2

- [Istio Architecture](#toc-istio-architecture)

- [Exploring Istio on K8s](#toc-exploring-istio-on-ks)

- [The Demo Installation](#toc-the-demo-installation)

.debug[(auto-generated TOC)]
---
name: toc-chapter-3

## Chapter 3

- [Deploying with Istio](#toc-deploying-with-istio)

.debug[(auto-generated TOC)]



.debug[[istio/toc.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/toc.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://images.pexels.com/photos/37859/sailing-ship-vessel-boat-sea-37859.jpeg)]

---

name: toc-what-is-a-service-mesh
class: title

What is a Service Mesh?

.nav[
[Previous section](#toc-)
|
[Back to table of contents](#toc-chapter-1)
|
[Next section](#toc-istio-architecture)
]

.debug[(automatically generated title slide)]

---
class: pic
# What is a Service Mesh?
![death star](images/observability_attwitter.png)
<p align="center">
*Twitter microservices having a little chat* </p>
.debug[[istio/servicemesh.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/servicemesh.md)]
---

## What is a Service Mesh?

*The less helpful definition*

The term service mesh is used to describe the network of microservices that make up distributed buisness applications and the interactions between these services.

As such distributed applications grow in size and complexity these interactions become ever harder to analyze, predict and maintain.

Our services need to conform to contracts and protocols but expect the unexpected to occur.

![img alt=><](images/mesh.png)

.debug[[istio/servicemesh.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/servicemesh.md)]
---

## The Reality of Distributed Systems

 - RPC instead of local communication

 - Network is unreliable

 - Latency is unpredictable

 - Call stack depth is unknown

 - Dependency on other services(and teams)

 - Services are ephemeral (i.e : they come and go without prior notice)
 
 - Unpredictable load 
.debug[[istio/servicemesh.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/servicemesh.md)]
---

## Types of Failures in Distributed Systems

 - improper fallback settings when a service is unavailable

 - retry storms from improperly tuned timeouts

 - outages when a downstream dependency receives too much traffic

 - cascading failures when a SPOF crashes
.debug[[istio/servicemesh.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/servicemesh.md)]
---


## Resilience Patterns

 - connection pools

 - failure detectors, to identify slow or crashed hosts

 - failover strategies:

    - circuit breaking

    - exponential back-offs

 - load-balancers

 - back-pressure techniques

    - rate limiting
    
    - choke packets
.debug[[istio/servicemesh.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/servicemesh.md)]
---

## Additional Concerns

 - Service Discovery

 - Observability 

    - Distributed tracing

    - Log aggregation

 - Security

    - Point-to-point mutual TLS

 - Continuous Deployments

    - Traffic splitting

    - Rolling updates

.debug[[istio/servicemesh.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/servicemesh.md)]
---
## Progressive Delivery

- Rolling Updates

- Blue-Green

- Canary

- Dark Launch

- Traffic Mirroring (shadowing)

.debug[[istio/servicemesh.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/servicemesh.md)]
---
## What Is A Service Mesh?

A network of lightweight, centrally configurable proxies taking care of inter-service traffic.

The puprpose of these proxies is to solve the application networking challenges.

They make application networking:

 - reliable

 - observable 
 
 - manageable

 ![img alt=><](images/mesh.png)
.debug[[istio/servicemesh.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/servicemesh.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://images.pexels.com/photos/173910/pexels-photo-173910.jpeg)]

---

name: toc-istio-architecture
class: title

Istio Architecture

.nav[
[Previous section](#toc-what-is-a-service-mesh)
|
[Back to table of contents](#toc-chapter-2)
|
[Next section](#toc-exploring-istio-on-ks)
]

.debug[(automatically generated title slide)]

---
class: pic
# Istio Architecture

![architecture](https://istio.io/docs/concepts/what-is-istio/arch.svg)

.debug[[istio/architecture.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/architecture.md)]
---
## Envoy

Envoy is a high-performance proxy developed in C++ to mediate all inbound and outbound traffic for all services in the service mesh. 

Istio leverages Envoy’s many built-in features, for example:

 - Dynamic service discovery
 - Load balancing
 - TLS termination
 - HTTP/2 and gRPC proxies
 - Circuit breakers
 - Health checks
 - Staged rollouts with %-based traffic split
 - Fault injection
 - Rich metrics

.debug[[istio/architecture.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/architecture.md)]
---

## The Sidecar Pattern
- The 'sidecar' is a an assistant container in the pod

- Think Batman's Robin

- It takes on some responsibility that the main container can't be bothered with
  
  - Log shipping

  - Data preparation

  - Or in our case : networking!
.debug[[istio/architecture.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/architecture.md)]
---

## Mixer
 
 Mixer is a platform-independent component. 

 - Enforces access control and usage policies

 - Collects telemetry data from the Envoy proxy and other Istio components.

 - The proxy extracts request level attributes, and sends them to Mixer for evaluation. 

 Mixer includes a flexible plugin model. 
.debug[[istio/architecture.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/architecture.md)]
---

## Pilot
 
  - Service discovery for the Envoy proxies

  - Traffic management capabilities for intelligent routing (e.g., A/B tests, canary rollouts, etc.)

  - Resiliency (timeouts, retries, circuit breakers, etc.).
.debug[[istio/architecture.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/architecture.md)]
---
  
## Citadel

- creates a SPIFFE certificate and key pair for each of the existing and new service accounts

- stores the certificate and key pairs as Kubernetes secrets.

- when you create a pod, Kubernetes mounts the certificate and key pair to the pod according to its service account 

- Citadel watches the lifetime of each certificate, and automatically rotates the certificates by rewriting the Kubernetes secrets.

.debug[[istio/architecture.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/architecture.md)]
---
## Galley

- validates configuration

- will abstract Istio from underlying platform (i.e Kubernetesß)
.debug[[istio/architecture.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/architecture.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://images.pexels.com/photos/746645/pexels-photo-746645.jpeg)]

---

name: toc-exploring-istio-on-ks
class: title

Exploring Istio on K8s

.nav[
[Previous section](#toc-istio-architecture)
|
[Back to table of contents](#toc-chapter-2)
|
[Next section](#toc-the-demo-installation)
]

.debug[(automatically generated title slide)]

---
# Exploring Istio on K8s

- Istio on Kubernetes stores all data in ... Kubernetes

- Istio installs 50+ [CRDs](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions)

- Kubernetes API serves and handles the storage of these custom resources

- That means we communicate with Istio control plane via the K8s API

.debug[[istio/exploreonk8s.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/exploreonk8s.md)]
---
## Exploring Istio on K8s
.exercise[
- Let us see these CRDs
  ```bash
  kubectl get crd | grep istio
  ```
- Let us count how many we got
  ```bash
  kubectl get crd | grep istio | wc -l
  ```
]
--


50 resource definitions! ( With mTLS that would've been 58 )

.debug[[istio/exploreonk8s.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/exploreonk8s.md)]
---
## Exploring Istio on K8s

 - Ok, that's where config is stored. But where are the processes?

```bash
kubectl get pod
```
 - Nothing here... Are they in kube-system?

```bash
kubectl get pod -n kube-system
```
 - Not here too!
.debug[[istio/exploreonk8s.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/exploreonk8s.md)]
---

## Exploring Istio on K8s

 - Let's look somewhere else

```bash
kubectl get ns
```
 - Hey, there's an *istio-system* namespace

```bash
kubectl get pod -n istio-system
```

- Now we're talking!

- But why so many?!


.debug[[istio/exploreonk8s.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/exploreonk8s.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://images.pexels.com/photos/1050656/pexels-photo-1050656.jpeg)]

---

name: toc-the-demo-installation
class: title

The Demo Installation

.nav[
[Previous section](#toc-exploring-istio-on-ks)
|
[Back to table of contents](#toc-chapter-2)
|
[Next section](#toc-deploying-with-istio)
]

.debug[(automatically generated title slide)]

---
# The Demo Installation

- microk8s installs the so-called _evaluation_ or _demo_ install of Istio

- It includes additional components:

  - Prometheus - for monitoring

  - Grafana - for dashboards

  - Jaeger - for tracing (see the istio-tracing-.. pod)

  - Servicegraph - to graph service connections

.debug[[istio/demoinstall.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoinstall.md)]
---
## The mixer pods

- We can see pilot, galley, citadel... But where is the mixer?

.exercise[
```bash
kubectl get pod -n istio-system -l=istio=mixer
```
]

- Mixer has 2 functions: defining traffic policy and exposing traffic telemetry. 

- Therefore - 2 pods.

.debug[[istio/demoinstall.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoinstall.md)]
---
## The sidecars

- Now, where are the Envoys?

- Let's look at the Pilot pod:

.exercise[
```bash
kubectl describe pod -n istio-system -l istio=pilot
```
]
--

```
Containers:
  discovery:
...
    Image:         docker.io/istio/pilot:1.0.5
...
  istio-proxy:
...
    Image:         docker.io/istio/proxyv2:1.0.5
```
.debug[[istio/demoinstall.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoinstall.md)]
---

### The sidecars

- But how do the sidecars get into our own pods?

- Let's deploy a service.

.exercise[
```bash
kubectl create deployment httpbin --image=kennethreitz/httpbin
```
]

- And look at the pod: 

.exercise[
```bash
kubectl describe pod -l=app=httpbin
```
]

- There's only one container. The sidecar proxy isn't there...

.debug[[istio/demoinstall.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoinstall.md)]
---

## The sidecar injection

- How do we inject the proxy into our pod?

- Do we need to edit our deployment ourselves?!

- There should be some magic somewhere!

- Remember when we looked at Istio pods there was that *sidecar-injector* pod?

- So why didn't it work?

.debug[[istio/demoinstall.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoinstall.md)]
---

## The sidecar injection

From Istio docs:
"When you deploy your application using kubectl apply, the Istio sidecar injector will automatically inject Envoy containers into your application pods if they are started in namespaces labeled with **istio-injection=enabled**."

- Let's label our namespace and redeploy:

.exercise[
```bash
kubectl label namespace default istio-injection=enabled
kubectl delete pod -l=app=httpbin
```
]
--

- Recreating that pod took a whole lotta time, didn't it?!

.debug[[istio/demoinstall.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoinstall.md)]
---

## The sidecar injection

- Look at our new pod:

.exercise[
```bash
kubectl describe pod -l=app=httpbin
```
]

- Now we have two containers and there was an [init-container](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/)!

- The istio-init container is run before the other containers are started and it's responsible for setting up the iptables rules so that all inbound/outbound traffic will go through Envoy

  - For a deep dive into what istio-init does - read this [blog post](https://medium.com/faun/understanding-how-envoy-sidecar-intercept-and-route-traffic-in-istio-service-mesh-20fea2a78833)


.debug[[istio/demoinstall.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoinstall.md)]
---

class: pic

.interstitial[![Image separating from the next chapter](https://images.pexels.com/photos/185799/pexels-photo-185799.jpeg)]

---

name: toc-deploying-with-istio
class: title

Deploying with Istio

.nav[
[Previous section](#toc-the-demo-installation)
|
[Back to table of contents](#toc-chapter-3)
|
[Next section](#toc-)
]

.debug[(automatically generated title slide)]

---
# Deploying with Istio

- Our purpose today is to learn how Istio allows us to implement *progressive delivery* techniques

- We'll do that by deploying a demo application - an *alphabeth* system :)

- It's just a frontend service that speaks to 2 backends (aleph and beth)

- All the services are bare-bones Python Flask apps
 
.debug[[istio/demoapp.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoapp.md)]
---

class: pic
## The Sample App 
![diagram](images/demoapp.png)

.debug[[istio/demoapp.md](https://github.com/otomato-gh/istio.workshop/tree/master/slides/istio/demoapp.md)]
---
```
Invalid chapter: 
```
</textarea>
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        ratio: '16:9',
        highlightSpans: true,
        excludedClasses: []
      });
    </script>
    
    <!-- 
    These two scripts will be available only when loading the
    content using the pub/sub server. Otherwise, they'll just
    404 and that's OK.
    -->
    <script src="/socket.io/socket.io.js">
    </script>
    <script src="/remote.js">
    </script>
  <div id="footer"> <img src="images/otologo.png"></div>
  </body>
</html>
